#include <msp430g2553.h>
#include <legacymsp430.h>


//#define IN_AD BIT2
//#define IN_AD_CH INCH_3
#define LED1 BIT0
#define LED2 BIT6
#define LEDS (LED1|LED2)

unsigned int ADC[5]; // recebere os valores 

int A0valor = 0;
int A1valor = 0;
int A2valor = 0;
int A3valor = 0;

int main(void)
{
  WDTCTL = WDTPW + WDTHOLD;
  
  BCSCTL1 = CALBC1_1MHZ;
  DCOCTL = CALDCO_1MHZ;
  
  P1OUT &= ~LEDS;
  P1DIR |= LEDS;
  P1SEL &= ~0x0F; 
  P1SEL2 &= ~0x0F;

  // Configura o canal 1 do Timer A em modo de comparacao
  // com periodo de 0,5 segundos
  TACCR0 = 62500-1;
  TACCR1 = TACCR0/2;
  TACCTL1 = OUTMOD_7;
  TACTL = TASSEL_2 | ID_3 | MC_1;
  
  // configuração do conversor AD para 4 entradas 
  ADC10CTL0 = REF2_5V + ADC10SHT_2 +MSC + REFON + ADC10ON + ADC10IE;
  ADC10AE0 = 0x0F; // são as entradas A0/A1/A2/A3
  ADC10CTL1 = INCH_4 + ADC10DIV_0 + ADC10SSEL_3 + CONSEQ_3 + SHS_0;// A4,A3,A2,A1,A0seleciona a sequencia do canal e habilita as portas e o clock  //
  ADC10DTC1 = 0x5;// manda fazer 5 conversões 
  ADC10SA = (short)&ADC[0];  // endereço inicial para as transferencias de dados do ADC10
  /*
  while(1)
  {
    // Manda comecar uma conversao
    ADC10CTL0 |= ENC + ADC10SC;
    // Espera a conversao ficar pronta
    while((ADC10CTL0 & ADC10IFG)==0);
    
    // Acende ou apaga o LED1
    // de acordo com a conversao AD
    if(ADC10MEM < 512)
      P1OUT |= LED1;
    else
       P1OUT &= ~LED1;

    // Inverte o LED2 para vermos
    // a temporizacao deste loop
     //P1OUT ^= LED2;
  }*/

  _BIS_SR(LPM0_bits+GIE);
  return 0;
}


interrupt(ADC10_VECTOR) ADC10_ISR(void)
{
    A0valor = ADC[0];  //ADC[0] tem o valor de A0
    A1valor = ADC[1];  //ADC[1] tem o valor de A1
    A2valor = ADC[2];  //ADC[2] tem o valor de A2
    A3valor = ADC[3];  //ADC[3] tem o valor de A3

   //ADC10CTL0 &= ~ADC10IFG;     // limpa flag de interrupção 
   ADC10SA = (short)&ADC[0];  // endereço inicial para as transferencias de dados do ADC10
   ADC10CTL0 |= ENC + ADC10SC;

    if(A0valor ==1){
       P1OUT |= LED1;
      }
     
   
  __bic_SR_register_on_exit(CPUOFF);        // Clear CPUOFF bit from 0(SR)
}

